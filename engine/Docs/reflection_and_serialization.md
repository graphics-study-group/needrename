# Reflection and Serialization

This document describes how the engine uses the Python version of **libclang** to parse code, generate reflection and serialization systems, and provide features such as class construction by name, calling member functions by name, accessing member variables by name, and automatically handling serialization, deserialization, and STL/smart pointer processing.

## Parser Workflow

1. **Parser Integration with CMake**

    - During engine build, **CMake** triggers the parser written in Python, located in the **`reflection_parser`** folder. CMake will create a config file which stores the current target name, the files to be parsed, the output directory for generated code and compiler options (e.g., std=c++20, ignoring header file errors).

    - If you want to parse some files in your own target, you can use following CMake code.

      ```cmake
      set(all_include_dirs)
      get_include_directories_for_target(my_target all_include_dirs)
      
      add_reflection_parser(
          target_name meta_my_target
          reflection_search_files "${CMAKE_CURRENT_SOURCE_DIR}/my_header.h"
          generated_code_dir "${CMAKE_CURRENT_LIST_DIR}/__generated__"
          reflection_search_include_dirs "${all_include_dirs}"
          parent_projects meta_parent_generation
      )
      add_dependencies(my_target meta_my_target)
      target_link_libraries(my_target PRIVATE meta_my_target)
      ```
      
      The code above call the function `add_reflection_parser`ï¼Œ generate an INTERFACE target "meta_my_target". Make sure to use **PRIVATE** link to generated meta target.
      
    - You can set parent projects for reflection parser. The parser will read the cached information about reflected types in the parent projects. Then the current target can parse the types in the parent projects as base types or member variables.

2. **Source Code Scanning**

    - The parser scans the provided files and reads the corresponding header files to ensure accurate parsing. However, it will not process reflection information from header files not listed in the giving file list.
    - The files to be analyzed for reflection must be header files.

3. **Reflection and Serialization Annotations**

    - The parser detects reflection and serialization information in the code through annotations, such as `[[clang::annotate("")]]`. These annotations are defined in the **`Reflection/macros.h`** file.

4. **Class Reflection and Serialization Modes**

    - Reflection and serialization can be controlled via **whitelist** and **blacklist** modes, defined using:

        - **`REFL_SER_CLASS(REFL_WHITELIST)`**: Only classes with the **ENABLE** annotation are reflected.
        - **`REFL_SER_CLASS(REFL_BLACKLIST)`**: Reflects all public fields that are not marked as **DISABLE**.
    - A class must include the macro **`REFL_SER_BODY(class_name)`** to generate automatic serialization member functions and a backdoor constructor for serialization.

5. **Function and Variable Reflection/Serialization**

    - Use **`REFL_ENABLE`** and **`REFL_DISABLE`** macros to control whether functions are reflected.
    - Use **`SER_ENABLE`** and **`SER_DISABLE`** macros to control whether member variables are serialized.
    - **`REFL_SER_ENABLE`** and **`REFL_SER_DISABLE`** control both reflection and serialization for member variables.
    - If you mark some vector, map or smart pointer for serialization, you need to include `Reflection/serialization_vector.h` , `Reflection/serialization_map.h` , etc.

6. **Generated Code Location**

    - The code generated by the parser is stored in the `__generated__/meta_${target_name}` folder. 

        This folder only contains implementations of some reflection and serialization functions. Users don't need to include any file in this folder except `reflection_init.cpp` which is for initialization.

    - Every target that is parsed requires the inclusion of **`#include "meta_${target}/reflection_init.ipp"`**. And ```RegisterAllTypes()``` should be called at the beginning of the executable to ensure the proper initialization of the reflection system, even if the engine's reflection system has already been initialized.

## Reflection System

The parser generates reflection for several key classes:

1. **Type**
    - Represents a class's type. It can hold any type, but only types marked as **`m_reflectable == true`** are considered for reflection. Types that support reflection can create instances of **`Var`** using **`Type::CreateInstance`**.
    - **Storage and Initialization**
      - A static hash table, **`s_index_type_map`**, stores shared pointers to **`Type`** instances, indexed by **`std::type_index`**.
      - Another static hash table, **`s_name_index_map`**, maps type names to their corresponding **`std::type_index`**.
      - During initialization, these tables are pre-registered with basic types like **`int`**, **`float`**, etc. Once the reflection system is initialized via the parser, all **`Type`** of reflected classes are registered into these tables.
    - **Type Retrieval**
      - The following functions are used to retrieve types:
        1. `GetType(const std::string &name)`:
           - The function searches the hash tables for the corresponding **`Type`** instance.
           - If found, it returns a shared pointer to the **`Type`**.
           - If not found, it returns **`nullptr`**.
        2. `GetType<T>()`
           - This function will search the hash table for `typeid(T)`. If not found, it will create a `Type` and return. But it won't register the created `Type` to the hash maps.
           - If `T` is a special type which we specifically handled such as `std::vector`, smart pointers, the function will return a specifically handled `Type`.
        3. `GetTypeFromObject(const T &obj)`:
           - Similar to `GetType<T>()`. 
           - If the obj is a polymorphic type, we will consider it as `typeid(obj)` instead of `T`.
    - **Type kinds**
        - A `Type` 's kind can be `None`, `Const`, `Pointer` . 
        - If the `Type` 's kind is `Const`, it can be dynamic casted to `ConstType`. A `Var` with const type can't invoke non-const method and will always get const `Var` members. 
        - If the `Type` 's kind is `Pointer`, it can be dynamic casted to `PointerType`. A `PointerType` can be a raw pointer or a shared, weak, unique pointer. Use `GetPointedType` to get the pointed type. A `Var` with pointer type can use `GetPointedVar` to a `Var` represents pointed data by the pointer.
2. **Var**
    - A container that holds a type and a pointer to an instance of that type (as a `void*`). You can cast the `void*` pointer to obtain the desired class type. The **`Var`** class also provides functions like **`Var::InvokeMethod`** and **`Var::GetMember`** to invoke member functions and access member variables. 
    - **Warning:** If the return value of the function called by `Var::InvokeMethod` is not void or reference, the system will `malloc` memory for it. The system won't call the returned type's constructor! And the returned `Var` will free the malloced memory when the `Var` is destructed. The `Var` won't call the object's destructor! **Make sure the type of returned value is simple basic type.**
    - **`Var`** supports polymorphism, meaning that if a **`Var`** holds an instance of type A but points to an object of type B (a derived class), **`InvokeMethod`** will invoke methods from type B.
3. **ArrayVar**
    - The reflection system only support array like types (raw array, std::vector, std::array) as member variables. Use `Var::GetArrayMember` to get an `ArrayVar`.
    - Use `Var ArrayVar::GetElement(size_t index)` to get the element `Var` at the given index.
    - `ArrayVar` can be `Resize`, `Append`, `Remove` if it's a `std::vector`

## Serialization System

1. **Serialization Functions**
    - The parser generates member functions for each reflective class as **`__serialization_save__`** and **`__serialization_load__`** to handle serialization and deserialization.
    - For special types like smart pointers or STL containers (e.g., `std::vector`), the serialization system implements specific outter serialization functions.
2. **Custom Serialization**
    - If a class wants to customize its serialization process, it can implement the functions:
        - **`save_to_archive(Archive&)`**
        - **`load_from_archive(Archive&)`**
    - The serialization system follows the priority:
        - Internal serialization functions > External serialization functions > Generated serialization functions.
    - You must include `Reflection/serialization.h` where you want to implement custom serialization functions.
3. **Serialization and Deserialization**
    - Developers can use the templates:
        - **`serialize(T, Archive)`**
        - **`deserialize(T, Archive)`**
    - These templates will automatically perform the serialization and deserialization process for the given type.
4. **Smart Pointer Serialization**
    - The serialization system supports smart pointers and ensures that the objects they point to are properly serialized and deserialized. It guarantees that multiple smart pointers pointing to the same object will not result in duplicate serialization or object creation.
    - **The smart pointer can not point to the main object to be serialized itself !!!**. If you have a class A, which has a smart pointer point to A itself. The serialization system will crash. If you want to do this, you must wrap class A with another class.

## Archive

1. **Concept of Archive**

    - An **Archive** holds a global context and the current state. The global context stores major data during serialization and deserialization, while the current state tracks the position in the data for reading or writing.
    - The global context includes:
        - A **JSON** representing the serialized data.
        - A pointer to extra data (e.g., binary data).
        - Markers and mappings for pointers to ensure correct handling during serialization.

2. **JSON Structure Example**

    - The JSON structure stores serialized data and object relationships. For example:

    ```json
    {
        "%data": {
            "&0": {
                "%type": "Engine::GameObjectAsset",
                "Asset::m_guid": "C052739654DA3905A0E7187B4DCDA668",
                "GameObjectAsset::m_MainObject": "&1"
            },
            "&1": {
                "%type": "Engine::GameObject",
                "GameObject::m_childGameObject": [],
                "GameObject::m_components": [
                    "&2",
                    "&3"
                ],
                "GameObject::m_name": "four_bunny",
                "GameObject::m_parentGameObject": null,
                "GameObject::m_transformComponent": "&2"
            },
            "&2": {
                "%type": "Engine::TransformComponent",
                "Component::m_parentGameObject": "&1",
                "TransformComponent::m_transform": {
                    "%type": "Engine::Transform",
                    "Transform::m_position": [
                        0.0,
                        0.0,
                        0.0
                    ],
                    "Transform::m_rotation": [
                        0.0,
                        0.0,
                        0.0,
                        1.0
                    ],
                    "Transform::m_scale": [
                        1.0,
                        1.0,
                        1.0
                    ]
                }
            },
            "&3": {
                "%type": "Engine::MeshComponent",
                "Component::m_parentGameObject": "&1",
                "MeshComponent::m_mesh_asset": "&8",
                "RendererComponent::m_cast_shadow": false,
                "RendererComponent::m_is_eagerly_loaded": false,
                "RendererComponent::m_layer": 4294967295,
                "RendererComponent::m_material_assets": [
                    "&4",
                    "&5",
                    "&6",
                    "&7"
                ],
                "RendererComponent::m_priority": 0
            },
            "&4": {
                "%type": "Engine::AssetRef",
                "AssetRef::m_guid": "09CDF049F5138FFA763A5D892A455966"
            },
            ......
            "&8": {
                "%type": "Engine::AssetRef",
                "AssetRef::m_guid": "D8676A9BA404F7A084DC7E30A9E5245D"
            }
        },
        "%main_id": "&0"
    }
    
    ```

    - The **`%data`** section stores all encountered objects, and the **`%main_id`** points to the main object being serialized.
    - Each object contains a **`%type`** field, which indicates the type of the object. During deserialization, this type information is used by the reflection system to properly reconstruct objects, ensuring correct polymorphic behavior.
    - Note that we use `class_name::member_name` to store the key of a member instead of full name including its parent namespace. Please make sure do not inherit different base classes with the same name (even if they are in different namespace).

3. **Additional Data in Archive**

    - The **extra_data** field in the archive is used to store additional binary data that cannot be directly represented in JSON. This is typically used for large assets like models or textures, where the serialized JSON data is not sufficient.

4. **File Storage**

    - An archive can be directly loaded from or saved to a file. The file is stored as a `abc.asset` JSON file, with additional data stored in a separate file (if applicable). The name of the extra data file is derived by removing the ```.asset``` suffix from the JSON file name.
