# Reflection and Serialization

This document describes how the engine uses the Python version of **libclang** to parse code, generate reflection and serialization systems, and provide features such as class construction by name, calling member functions by name, accessing member variables by name, and automatically handling serialization, deserialization, and STL/smart pointer processing.

## Parser Workflow

1. **Parser Integration with CMake**

    - During engine build, **CMake** triggers the parser written in Python, located in the **`reflection_parser`** folder. The parser is informed of the current target, the files to be analyzed for reflection, the output directory for generated code, and the file that defines reflection macros. Compiler options (e.g., std=c++20, ignoring header file errors) are also passed.

2. **Source Code Scanning**

    - The parser scans the provided files and reads the corresponding header files to ensure accurate parsing. However, it will not process reflection information from header files not listed in the giving file list.
    - The files to be analyzed for reflection must be header files.

3. **Reflection and Serialization Annotations**

    - The parser detects reflection and serialization information in the code through annotations, such as `[[clang::annotate("")]]`. These annotations are defined in the **`Reflection/macros.h`** file.

4. **Class Reflection and Serialization Modes**

    - Reflection and serialization can be controlled via **whitelist** and **blacklist** modes, defined using:

        - **`REFL_SER_CLASS(REFL_WHITELIST)`**: Only classes with the **ENABLE** annotation are reflected.
        - **`REFL_SER_CLASS(REFL_BLACKLIST)`**: Reflects all public fields that are not marked as **DISABLE**.
    - A class must include the macro **`REFL_SER_BODY(class_name)`** to generate automatic serialization member functions and a backdoor constructor for serialization.

5. **Function and Variable Reflection/Serialization**

    - Use **`REFL_ENABLE`** and **`REFL_DISABLE`** macros to control whether functions are reflected.
    - Use **`SER_ENABLE`** and **`SER_DISABLE`** macros to control whether member variables are serialized.
    - **`REFL_SER_ENABLE`** and **`REFL_SER_DISABLE`** control both reflection and serialization for member variables.

6. **Generated Code Location**

    - The code generated by the parser is stored in the `__generated__/meta_{target_name}` folder. 

        Developers can include the generated reflection header file with:

        ```c++
        #include <meta_{target_name}/reflection.hpp>
        ```
        
    - Every target that is parsed requires the inclusion of **`#include "meta_target/reflection_init.ipp"`**. And ```RegisterAllTypes()``` should be called at the beginning of the executable to ensure the proper initialization of the reflection system, even if the engine's reflection system has already been initialized.

## Reflection System

The parser generates reflection for several key classes:

1. **Type**
    - Represents a class's type. It can hold any type, but only types marked as **`m_reflectable == true`** are considered for reflection. Types that support reflection can create instances of **`Var`** using **`Type::CreateInstance`**.
2. **Var**
    - A container that holds a type and a pointer to an instance of that type (as a `void*`). You can cast the `void*` pointer to obtain the desired class type. The **`Var`** class also provides functions like **`Var::InvokeMethod`** and **`Var::GetMember`** to invoke member functions and access member variables. 
    - **`Var`** supports polymorphism, meaning that if a **`Var`** holds an instance of type A but points to an object of type B (a derived class), **`InvokeMethod`** will invoke methods from type B.

## Serialization System

1. **Serialization Functions**
    - The parser generates member functions for each reflective class as **`__serialization_save__`** and **`__serialization_load__`** to handle serialization and deserialization.
    - For special types like smart pointers or STL containers (e.g., `std::vector`), the serialization system implements specific serialization functions.
2. **Custom Serialization**
    - If a class wants to customize its serialization process, it can implement the functions:
        - **`save_to_archive(Archive&)`**
        - **`load_from_archive(Archive&)`**
    - The serialization system follows the priority:
        - Custom serialization functions > Special serialization functions for specific types (e.g., smart pointers) > Generated serialization functions.
3. **Serialization and Deserialization**
    - Developers can use the templates:
        - **`serialize(T, Archive)`**
        - **`deserialize(T, Archive)`**
    - These templates will automatically perform the serialization and deserialization process for the given type.
4. **Smart Pointer Serialization**
    - The serialization system supports smart pointers and ensures that the objects they point to are properly serialized and deserialized. It guarantees that multiple smart pointers pointing to the same object will not result in duplicate serialization or object creation.
    - **The smart pointer can not point to the main object to be serialized itself !!!**. If you have a class A, which has a smart pointer point to A itself. The serialization system will crash. If you want to do this, you must wrap class A with another class.

## Archive

1. **Concept of Archive**

    - An **Archive** holds a global context and the current state. The global context stores major data during serialization and deserialization, while the current state tracks the position in the data for reading or writing.
    - The global context includes:
        - A **JSON** representing the serialized data.
        - A pointer to extra data (e.g., binary data).
        - Markers and mappings for pointers to ensure correct handling during serialization.

2. **JSON Structure Example**

    - The JSON structure stores serialized data and object relationships. For example:

    ```json
    {
        "%data": {
            "&0": {
                "%type": "Engine::GameObjectAsset",
                "Asset::m_guid": "01F4F0E99D638E56EDB9056558E15A68",
                "m_MainObject": "&1"
            },
            "&1": {
                "%type": "Engine::GameObject",
                "m_childGameObject": [],
                "m_components": [
                    "&2",
                    "&3"
                ],
                "m_parentGameObject": null,
                "m_transformComponent": "&2"
            },
            "&2": {
                "%type": "Engine::TransformComponent",
                "Component::m_parentGameObject": "&1"
            },
            ....
        },
        "%main_id": "&0"
    }
    ```

    - The **`%data`** section stores all encountered objects, and the **`%main_id`** points to the main object being serialized.
    - Each object contains a **`%type`** field, which indicates the type of the object. During deserialization, this type information is used by the reflection system to properly reconstruct objects, ensuring correct polymorphic behavior.

3. **Additional Data in Archive**

    - The **extra_data** field in the archive is used to store additional binary data that cannot be directly represented in JSON. This is typically used for large assets like models or textures, where the serialized JSON data is not sufficient.

4. **File Storage**

    - An archive can be directly loaded from or saved to a file. The file is stored as a `abc.asset` JSON file, with additional data stored in a separate file (if applicable). The name of the extra data file is derived by removing the ```.asset``` suffix from the JSON file name.
