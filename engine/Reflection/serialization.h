#ifndef REFLECTION_SERIALIZATION_INCLUDED
#define REFLECTION_SERIALIZATION_INCLUDED

#include "Archive.h"
#include "serialization_base.h"
#include "utils.h"

namespace Engine {
    namespace Serialization {
        /***********************************************************************
         * Utilities for backdoor
         * constructor.
         *
         * The backdoor constructor is generated by the parser if the class is marked
         * reflectable.
         * It has one parameter of type SerializationMarker and it will do nothing in the
         * function body.
         * This constructor is used only in serilization process, in order to deserialize the
         * class which has no default constructor.

         * ***********************************************************************/

        /// @brief concept to check if a type is constructible with T(SerializationMarker). This constructor should be
        /// generated by the parser if the class is marked reflectable.
        template <typename T>
        concept backdoor_constructible = std::is_constructible<T, SerializationMarker>::value;

        /// @brief try create_shared with backdoor constructor std::make_shared<T>(SerializationMarker{}). otherwise use
        /// normal make_shared<T>()
        template <typename T>
            requires(backdoor_constructible<T>)
        std::shared_ptr<T> backdoor_create_shared() {
            return std::make_shared<T>(SerializationMarker{});
        }
        /// @brief try create_shared with backdoor constructor std::make_shared<T>(SerializationMarker{}). otherwise use
        /// normal make_shared<T>()
        template <typename T>
            requires(!backdoor_constructible<T>)
        std::shared_ptr<T> backdoor_create_shared() {
            return std::make_shared<T>();
        }

        /// @brief try create_unique with backdoor constructor std::make_unique<T>(SerializationMarker{}). otherwise use
        /// normal make_unique<T>()
        template <typename T>
            requires(backdoor_constructible<T>)
        std::unique_ptr<T> backdoor_create_unique() {
            return std::make_unique<T>(SerializationMarker{});
        }
        /// @brief try create_unique with backdoor constructor std::make_unique<T>(SerializationMarker{}). otherwise use
        /// normal make_unique<T>()
        template <typename T>
            requires(!backdoor_constructible<T>)
        std::unique_ptr<T> backdoor_create_unique() {
            return std::make_unique<T>();
        }

        /***********************************************************************
         * Serialization Functions
         * Selection
         *
         * Use SFINAE to select the correct serialization function for a type.
 * The
         * selection order is internal save/load > external save/load > generated save/load.

         * ***********************************************************************/

        template <typename T>
        concept has_internal_save = requires(const T &value, Archive &archive) { value.save_to_archive(archive); };
        template <typename T>
        concept has_internal_load = requires(T &value, Archive &archive) { value.load_from_archive(archive); };

        template <typename T>
        concept has_external_save = requires(const T &value, Archive &archive) { save_to_archive(value, archive); };
        template <typename T>
        concept has_external_load = requires(T &value, Archive &archive) { load_from_archive(value, archive); };

        template <typename T>
        concept has_generated_save =
            requires(const T &value, Archive &archive) { value._SERIALIZATION_SAVE_(archive); };
        template <typename T>
        concept has_generated_load = requires(T &value, Archive &archive) { value._SERIALIZATION_LOAD_(archive); };

        template <typename T>
        concept has_save = has_internal_save<T> || has_external_save<T> || has_generated_save<T>;

        template <typename T>
        concept has_load = has_internal_load<T> || has_external_load<T> || has_generated_load<T>;

        template <has_save T>
        void serialize(const T &value, Archive &archive) {
            if (!archive.m_context->save_prepared) {
                archive.prepare_save();
            }
            if constexpr (has_internal_save<T>) {
                value.save_to_archive(archive);
            } else if constexpr (has_external_save<T>) {
                save_to_archive(value, archive);
            } else if constexpr (has_generated_save<T>) {
                value._SERIALIZATION_SAVE_(archive);
            }
        }

        template <has_load T>
        void deserialize(T &value, Archive &archive) {
            if (!archive.m_context->load_prepared) {
                archive.prepare_load();
            }
            if constexpr (has_internal_load<T>) {
                value.load_from_archive(archive);
            } else if constexpr (has_external_load<T>) {
                load_from_archive(value, archive);
            } else if constexpr (has_generated_load<T>) {
                value._SERIALIZATION_LOAD_(archive);
            }
        }
    } // namespace Serialization
} // namespace Engine

#endif // REFLECTION_SERIALIZATION_INCLUDED
