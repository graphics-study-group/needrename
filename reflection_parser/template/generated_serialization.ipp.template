#include "generated_serialization.hpp"
#include "all_reflection_files.hpp"
#include "Reflection/serialization.h"

<%
import clang.cindex as CX
%>

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

namespace Engine
{
    namespace Serialization
    {
        ## list of all basic types such as bool, int, long double
        <% basic_type_list = [CX.TypeKind.from_id(i) for i in range(3, 24)] %>
        % for class_type in classes_map.values():
        void save(const ${class_type.full_name} &value, Archive& buffer)
        {
            % for base_type in class_type.base_types:
            {
                Archive temp_buffer;
                serialize((const ${base_type.full_name} &)value, temp_buffer);
                buffer.json["${base_type.name}"] = temp_buffer.json;
                buffer.buffers.insert(buffer.buffers.end(), temp_buffer.buffers.begin(), temp_buffer.buffers.end());
            }
            % endfor

            Json &json = buffer.json;
            
            % for field in class_type.serialized_fields:
            % if field.type.cx_type.kind in basic_type_list:
            {
                json["${field.name}"] = value.${field.name};
            }
            % elif field.type.cx_type.kind == CX.TypeKind.POINTER:
            {
                if (value.${field.name} != nullptr)
                {
                % if field.type.cx_type.get_pointee().kind in basic_type_list:
                    json["${field.name}"] = *value.${field.name};
                % else:
                    Archive temp_buffer;
                    serialize(*value.${field.name}, temp_buffer);
                    json["${field.name}"] = temp_buffer.json;
                % endif
                }
            }
            % elif field.type.cx_type.kind == CX.TypeKind.CONSTANTARRAY:
            {
                json["${field.name}"] = Json::array();
                for (const auto& item : value.${field.name})
                {
                % if field.type.cx_type.element_type.kind in basic_type_list:
                    json["${field.name}"].push_back(item);
                % else:
                    Archive temp_buffer;
                    serialize(item, temp_buffer);
                    json["${field.name}"].push_back(temp_buffer.json);
                    buffer.buffers.insert(buffer.buffers.end(), temp_buffer.buffers.begin(), temp_buffer.buffers.end());
                % endif
                }
            }
            % else:
            {
                Archive temp_buffer;
                serialize(value.${field.name}, temp_buffer);
                json["${field.name}"] = temp_buffer.json;
                buffer.buffers.insert(buffer.buffers.end(), temp_buffer.buffers.begin(), temp_buffer.buffers.end());
            }
            % endif
            % endfor
        }
        % endfor

        % for class_type in classes_map.values():
        void load(const ${class_type.full_name} &value, Archive& buffer)
        {
            
        }
        % endfor
    }
}

#pragma GCC diagnostic pop
