#include <memory>
#include <Reflection/Type.h>

namespace Engine
{
    namespace Reflection
    {
        class Type;

        class TypeRegistrar
        {
        public:
            % for class_type in classes_map.values():
            <% class_name = class_type.name %>
            static std::shared_ptr<Type> Register_${class_name}()
            {
                std::shared_ptr<Type> type = std::shared_ptr<Type>(new Type("${class_name}", &typeid(${class_name}), true));

                % for constructor in class_type.constructors:
                type->AddConstructor<\
                    % for i in range(len(constructor.arg_types)):
${constructor.arg_types[i]}\
                        % if i < len(constructor.arg_types) - 1:
, \
                        % endif
                    % endfor
>(
                    [](void *obj, void *&ret, std::vector<void *> args)
                    { ret = static_cast<void *>(new FooA(\
                        % for i in range(len(constructor.arg_types)):
*static_cast<${constructor.arg_types[i]} *>(args[${i}])\
                            % if i < len(constructor.arg_types) - 1:
, \
                            % endif
                        % endfor
)); });
                % endfor

                % for method in class_type.methods:
                type->AddMethod(
                    "${method.name}",
                    [](void *obj, void *&ret, std::vector<void *> args)
                    { \
                        % if method.return_type != "void":
void *ret_ptr = malloc(sizeof(${method.return_type})); *ret_ptr = static_cast<${class_name} *>(obj)->${method.name}(\
                        % else:
static_cast<${class_name} *>(obj)->${method.name}(\
                        % endif
                        % for i in range(len(method.arg_types)):
*static_cast<${method.arg_types[i]} *>(args[${i}])\
                            % if i < len(method.arg_types) - 1:
, \
                            % endif
                        % endfor
); \
                        % if method.return_type != "void":
                            ret = ret_ptr;\
                        % endif
},
                    GetType("${method.return_type}"),
                    &${class_name}::${method.name});
                % endfor
                
                % for field in class_type.fields:
                type->AddField(
                    GetType("${field.type}"),
                    "${field.name}",
                    [](void *obj, void *&ret)
                    { ret = static_cast<void *>(&static_cast<${class_name} *>(obj)->${field.name}); });
                % endfor

                Type::s_type_map["${class_name}"] = type;
                return type;
            }
            % endfor
        };

        void Registrar::RegisterAllTypes()
        {
            % for class_type in classes_map.values():
            auto Type_${class_type.name} = TypeRegistrar::Register_${class_type.name}();
            % endfor

            % for class_type in topological_sorted_types:
            % for base_type in class_type.base_types:
            % if base_type in classes_map:
            Type_${class_type.name}->AddBaseType(Type_${base_type});
            % endif
            % endfor
            % endfor
        }
    }
}
