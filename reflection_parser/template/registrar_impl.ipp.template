#include <memory>
#include <typeindex>
#include <typeinfo>
#include <Reflection/reflection.h>
#include "registrar_declare.hpp"
#include "${file_path}"

<%def name="generate_headers(class_type)">
% for smart_pointer_typename in class_type.reflection_smart_pointer_typenames:
% if smart_pointer_typename in parser.type_file_map.keys():
#include "${parser.type_file_map[smart_pointer_typename]}"
% endif
% endfor
</%def>

% if file_path in parser.file_type_map.keys():
% for class_type in parser.file_type_map[file_path]:
${generate_headers(class_type)}
% endfor
% endif

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

namespace Engine
{
    namespace Reflection
    {
        class Type;

        % if file_path in parser.file_enum_map.keys():
        static constexpr size_t hash_string_view(std::string_view v)
        {
            size_t hash = 0xcbf29ce484222325ull;
            constexpr size_t prime = 0x100000001b3ull;
            for (char c : v)
            {
                hash ^= static_cast<size_t>(c);
                hash *= prime;
            }
            return hash;
        }
        % endif

        % if file_path in parser.file_type_map.keys():
        % for class_type in parser.file_type_map[file_path]:
        std::shared_ptr<Type> TypeRegistrar::Register_${class_type.mangled_name}()
        {
            std::shared_ptr<Type> type = std::shared_ptr<Type>(new Type("${class_type.full_name}", sizeof(${class_type.full_name}), true));

            Type::s_index_type_map[std::type_index(typeid(${class_type.full_name}))] = type;
            Type::s_name_index_map.emplace("${class_type.full_name}", std::type_index(typeid(${class_type.full_name})));
            PointerType::RegisterSmartPointerGetFunc<${class_type.full_name}>();
            return type;
        }
        % endfor

        % for class_type in parser.file_type_map[file_path]:
        void TypeRegistrar::RegisterMethodField_${class_type.mangled_name}(std::shared_ptr<Type> type)
        {
            % for constructor in class_type.constructors:
            type->AddConstructor<\
                % for i in range(len(constructor.arg_types)):
${constructor.arg_types[i].full_name}\
                    % if i < len(constructor.arg_types) - 1:
, \
                    % endif
                % endfor
>(
                [](void *obj, void *&ret, const std::vector<void *> &args)
                { ret = static_cast<void *>(new ${class_type.full_name}(\
                    % for i in range(len(constructor.arg_types)):
*reinterpret_cast<std::remove_reference<${constructor.arg_types[i].full_name}>::type *>(args[${i}])\
                        % if i < len(constructor.arg_types) - 1:
, \
                        % endif
                    % endfor
)); });
            % endfor

            type->SetDeconstructor(
                [](void *obj)
                { delete static_cast<std::add_pointer<${class_type.full_name}>::type>(obj); }
            );

            % for method in class_type.methods:
            type->AddMethod<\
                % for i in range(len(method.arg_types)):
${method.arg_types[i].full_name}\
                    % if i < len(method.arg_types) - 1:
, \
                    % endif
                % endfor
>(
                "${method.name}",
                [](void *obj, void *&ret, const std::vector<void *> &args)
                { \
                    % if method.return_type_is_reference:
ret = const_cast<void*>(reinterpret_cast<const void *>(&static_cast<std::remove_reference<${class_type.full_name}>::type *>(obj)->${method.name}(\
                    % elif method.return_type.name == "void":
static_cast<std::add_pointer<${class_type.full_name}>::type>(obj)->${method.name}(\
                    % else:
std::add_pointer<${method.return_type.full_name}>::type ret_ptr = new ${method.return_type.full_name}(); *ret_ptr = static_cast<std::add_pointer<${class_type.full_name}>::type>(obj)->${method.name}(\
                    % endif
                    % for i in range(len(method.arg_types)):
*reinterpret_cast<std::remove_reference<${method.arg_types[i].full_name}>::type *>(args[${i}])\
                        % if i < len(method.arg_types) - 1:
, \
                        % endif
                    % endfor
                    % if method.return_type_is_reference:
))); \
                    % elif method.return_type.name == "void":
); \
                    % else:
); ret = reinterpret_cast<void *>(ret_ptr);\
                    % endif
}, 
                GetType<${method.return_type.full_name}>(),
                % if method.is_const:
                true,
                % else:
                false,
                % endif
                % if method.return_type_is_reference:
                false
                % elif method.return_type.name == "void":
                false
                % else:
                true
                % endif
            );
            % endfor
            
            % for field in class_type.fields:
            type->AddField(
                GetType<${field.type.full_name}>(),
                "${field.name}",
                [](void *obj, void *&ret)
                { ret = static_cast<void *>(&static_cast<${class_type.full_name} *>(obj)->${field.name}); });
            % if field.array_type == "ConstArray":
            type->AddArrayField(
                GetType<${field.element_type_full_name}>(),
                "${field.name}",
                [](void *obj, size_t index, void *&ret)
                { ret = static_cast<void *>(&static_cast<${class_type.full_name} *>(obj)->${field.name}[index]); },
                [](void *obj, size_t &size)
                { size = ${field.type.cx_type.get_array_size()}u; },
                nullptr
            );
            % elif field.array_type == "StdVector":
            type->AddArrayField(
                GetType<${field.element_type_full_name}>(),
                "${field.name}",
                [](void *obj, size_t index, void *&ret)
                { ret = static_cast<void *>(&static_cast<${class_type.full_name} *>(obj)->${field.name}[index]); },
                [](void *obj, size_t &size)
                { size = static_cast<${class_type.full_name} *>(obj)->${field.name}.size(); },
                [](void *obj, size_t new_size)
                { static_cast<${class_type.full_name} *>(obj)->${field.name}.resize(new_size); }
            );
            % elif field.array_type == "StdArray":
            type->AddArrayField(
                GetType<${field.element_type_full_name}>(),
                "${field.name}",
                [](void *obj, size_t index, void *&ret)
                { ret = static_cast<void *>(&static_cast<${class_type.full_name} *>(obj)->${field.name}[index]); },
                [](void *obj, size_t &size)
                { size = static_cast<${class_type.full_name} *>(obj)->${field.name}.size(); },
                nullptr
            );
            % endif
            % endfor
        }
        % endfor
        % endif

        % if file_path in parser.file_enum_map.keys():
        % for enum_type in parser.file_enum_map[file_path]:
        std::shared_ptr<EnumType> TypeRegistrar::Register_${enum_type.mangled_name}()
        {
            std::shared_ptr<EnumType> type = std::shared_ptr<EnumType>(
                new EnumType(
                    "${enum_type.full_name}", 
                    sizeof(${enum_type.full_name}), 
                    true,
                    {
                        % for i, value in enumerate(enum_type.values):
                        static_cast<uint64_t>(${enum_type.full_name}::${value})\
                            % if i < len(enum_type.values) - 1:
,
                            % else:

                            % endif
                        % endfor
                    },
                    [](uint64_t value) -> std::string_view {
                        switch(static_cast<${enum_type.full_name}>(value))
                        {
                            % for value in enum_type.values:
                            case ${enum_type.full_name}::${value}: return "${value}";
                            % endfor
                            default: return "";
                        }
                    },
                    [](const std::string_view &name) -> std::optional<uint64_t> {
                        auto hash = hash_string_view(name);
                        switch(hash)
                        {
                            % for value in enum_type.values:
                            case hash_string_view("${value}"): return static_cast<uint64_t>(${enum_type.full_name}::${value});
                            % endfor
                            default: return std::nullopt;
                        }
                    }
                )
            );
            Type::s_index_type_map[std::type_index(typeid(${enum_type.full_name}))] = type;
            Type::s_name_index_map.emplace("${enum_type.full_name}", std::type_index(typeid(${enum_type.full_name})));
            PointerType::RegisterSmartPointerGetFunc<${enum_type.full_name}>();
            return type;
        }
        % endfor
        % endif
    }
}

#pragma GCC diagnostic pop
