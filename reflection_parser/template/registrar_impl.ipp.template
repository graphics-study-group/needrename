#include <memory>
#include <Reflection/Type.h>

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

namespace Engine
{
    namespace Reflection
    {
        class Type;

        % for class_type in classes_map.values():
        <% class_name, mangled_name = class_type.name, class_type.mangled_name %>
        std::shared_ptr<Type> TypeRegistrar::Register_${mangled_name}()
        {
            std::shared_ptr<Type> type = std::shared_ptr<Type>(new Type("${class_name}", &typeid(${class_name}), true));

            % for constructor in class_type.constructors:
            type->AddConstructor<\
                % for i in range(len(constructor.arg_types)):
${constructor.arg_types[i]}\
                    % if i < len(constructor.arg_types) - 1:
, \
                    % endif
                % endfor
>(
                [](void *obj, void *&ret, const std::vector<void *> &args)
                { ret = static_cast<void *>(new ${class_name}(\
                    % for i in range(len(constructor.arg_types)):
*reinterpret_cast<std::remove_reference<${constructor.arg_types[i]}>::type *>(args[${i}])\
                        % if i < len(constructor.arg_types) - 1:
, \
                        % endif
                    % endfor
)); });
            % endfor

            % for method in class_type.methods:
            type->AddMethod<\
                % for i in range(len(method.arg_types)):
${method.arg_types[i]}\
                    % if i < len(method.arg_types) - 1:
, \
                    % endif
                % endfor
>(
                "${method.name}",
                [](void *obj, void *&ret, const std::vector<void *> &args)
                { \
                    % if method.return_type_is_reference:
ret = reinterpret_cast<void *>(&static_cast<std::remove_reference<${class_name}>::type *>(obj)->${method.name}(\
                    % elif method.return_type == "void":
static_cast<std::remove_reference<${class_name}>::type *>(obj)->${method.name}(\
                    % else:
std::remove_reference<${method.return_type}>::type *ret_ptr = reinterpret_cast<std::remove_reference<${method.return_type}>::type *>(malloc(sizeof(${method.return_type}))); *ret_ptr = static_cast<std::remove_reference<${class_name}>::type *>(obj)->${method.name}(\
                    % endif
                    % for i in range(len(method.arg_types)):
*reinterpret_cast<std::remove_reference<${method.arg_types[i]}>::type *>(args[${i}])\
                        % if i < len(method.arg_types) - 1:
, \
                        % endif
                    % endfor
                    % if method.return_type_is_reference:
)); \
                    % elif method.return_type == "void":
); \
                    % else:
); ret = reinterpret_cast<void *>(ret_ptr);\
                    % endif
}, 
                % if method.is_const:
                [](const void *obj, void *&ret, const std::vector<void *> &args)
                { \
                    % if method.return_type != "void":
std::remove_reference<${method.return_type}>::type *ret_ptr = reinterpret_cast<std::remove_reference<${method.return_type}>::type *>(malloc(sizeof(${method.return_type}))); *ret_ptr = static_cast<std::add_const<std::remove_reference<${class_name}>::type>::type *>(obj)->${method.name}(\
                    % else:
static_cast<std::add_const<std::remove_reference<${class_name}>::type>::type *>(obj)->${method.name}(\
                    % endif
                    % for i in range(len(method.arg_types)):
*reinterpret_cast<std::remove_reference<${method.arg_types[i]}>::type *>(args[${i}])\
                        % if i < len(method.arg_types) - 1:
, \
                        % endif
                    % endfor
); \
                    % if method.return_type != "void":
ret = reinterpret_cast<void *>(ret_ptr);\
                    % endif
},
                % else:
                nullptr,
                % endif
                GetType("${method.return_type}"));
            % endfor
            
            % for field in class_type.fields:
            type->AddField(
                GetType("${field.type}"),
                "${field.name}",
                [](void *obj, void *&ret)
                { ret = static_cast<void *>(&static_cast<${class_name} *>(obj)->${field.name}); },
                [](const void *obj, const void *&ret)
                { ret = static_cast<const void *>(&static_cast<const ${class_name} *>(obj)->${field.name}); });
            % endfor

            Type::s_type_map["${class_name}"] = Type::s_type_map[typeid(${class_name}).name()] = type;
            return type;
        }
        % endfor

        void Registrar::RegisterAllTypes()
        {
            % for class_type in classes_map.values():
            auto Type_${class_type.mangled_name} = TypeRegistrar::Register_${class_type.mangled_name}();
            % endfor

            % for class_type in topological_sorted_types:
            % for base_type in class_type.base_types:
            % if base_type in classes_map:
            Type_${class_type.mangled_name}->AddBaseType(Type_${classes_map[base_type].mangled_name});
            % endif
            % endfor
            % endfor
        }
    }
}

#pragma GCC diagnostic pop
