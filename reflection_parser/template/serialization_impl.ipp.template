#include <Reflection/serialization.h>

<%
import clang.cindex as CX
%>

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-parameter"

## list of all basic types such as bool, int, long double
<% basic_type_list = [CX.TypeKind.from_id(i) for i in range(3, 24)] %>

<%def name="generate_type_save(class_type, prefix)">
    % for base_type in class_type.base_types:
    % if base_type.full_name in classes_map:
    {
        ${generate_type_save(classes_map[base_type.full_name], base_type.name + "::")}  
    }
    % endif
    % endfor

    % for field in class_type.serialized_fields:
    % if field.type.cx_type.kind in basic_type_list:
    {
        json["${prefix + field.name}"] = this->${field.name};
    }
    % else:
    {
        json["${prefix + field.name}"] = Engine::Serialization::Json::object();
        Engine::Serialization::Archive temp_archive(archive, &json["${prefix + field.name}"]);
        serialize(this->${field.name}, temp_archive);
    }
    % endif
    % endfor
</%def>
% for class_type in classes_map.values():
void ${class_type.full_name}::__serialization_save__(Engine::Serialization::Archive& archive) const
{
    if (!archive.m_context->save_prepared)
        archive.prepare_save("Anything");
    Engine::Serialization::Json &json = *archive.m_cursor;
    
    ${generate_type_save(class_type, "")}

    assert(json.find("%type") == json.end());
    json["%type"] = "${class_type.full_name}";
}
<%def name="generate_type_load(class_type, prefix)">
    % for base_type in class_type.base_types:
    % if base_type.full_name in classes_map:
    {
        ${generate_type_load(classes_map[base_type.full_name], base_type.name + "::")}
    }
    % endif
    % endfor
    
    % for field in class_type.serialized_fields:
    % if field.type.cx_type.kind in basic_type_list:
    {
        if (json.find("${prefix + field.name}") != json.end())
        {
            this->${prefix + field.name} = json["${prefix + field.name}"];
        }
    }
    % elif field.type.cx_type.kind == CX.TypeKind.POINTER:
    {
        if (json.find("${prefix + field.name}") != json.end())
        {
            Engine::Serialization::Archive temp_archive(archive, &json["${prefix + field.name}"]);
            deserialize(this->${prefix + field.name}, temp_archive);
        }
        else
        {
            this->${prefix + field.name} = nullptr;
        }
    }
    % else:
    {
        if (json.find("${prefix + field.name}") != json.end())
        {
            Engine::Serialization::Archive temp_archive(archive, &json["${prefix + field.name}"]);
            deserialize(this->${prefix + field.name}, temp_archive);
        }
    }
    % endif
    % endfor
</%def>
void ${class_type.full_name}::__serialization_load__(Engine::Serialization::Archive& archive)
{
    if (!archive.m_context->load_prepared)
        archive.prepare_load();

    Engine::Serialization::Json &json = *archive.m_cursor;
    ${generate_type_load(class_type, "")}
}
% endfor

#pragma GCC diagnostic pop
