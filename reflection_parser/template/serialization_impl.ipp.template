#include <Reflection/serialization.h>
#include "${file_path}"

<%def name="generate_headers(class_type)">
% for smart_pointer_typename in class_type.serialization_smart_pointer_typenames:
% if smart_pointer_typename in parser.type_file_map.keys():
#include "${parser.type_file_map[smart_pointer_typename]}"
% endif
% endfor
</%def>

% for class_type in parser.file_type_map[file_path]:
${generate_headers(class_type)}
% endfor

<%
import clang.cindex as CX
%>

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-parameter"

## list of all basic types such as bool, int, long double
<% 
basic_type_list = [CX.TypeKind.from_id(i) for i in range(3, 24)]
extra_basic_type_name_list = ["std::string", "int8_t", "int16_t", "int32_t", "int64_t", "uint8_t", "uint16_t", "uint32_t", "uint64_t", "int_least8_t", "int_least16_t", "int_least32_t", "int_least64_t", "uint_least8_t", "uint_least16_t", "uint_least32_t", "uint_least64_t", "int_fast8_t", "int_fast16_t", "int_fast32_t", "int_fast64_t", "uint_fast8_t", "uint_fast16_t", "uint_fast32_t", "uint_fast64_t", "intmax_t", "intptr_t", "uintmax_t", "uintptr_t"]
%>

<%def name="generate_type_save(class_type)">
    % for field in class_type.serialized_fields:
    % if field.type.cx_type.kind in basic_type_list or field.type.cx_type.spelling in extra_basic_type_name_list:
    {
        json["${class_type.name + "::" +  field.name}"] = this->${class_type.name + "::" +  field.name};
    }
    % else:
    {
        json["${class_type.name + "::" +  field.name}"] = Engine::Serialization::Json::object();
        Engine::Serialization::Archive temp_archive(archive, &json["${class_type.name + "::" +  field.name}"]);
        serialize(this->${field.name}, temp_archive);
    }
    % endif
    % endfor
</%def>
<%def name="generate_type_load(class_type)">
    % for field in class_type.serialized_fields:
    % if field.type.cx_type.kind in basic_type_list or field.type.cx_type.spelling in extra_basic_type_name_list:
    {
        if (json.find("${class_type.name + "::" +  field.name}") != json.end())
        {
            this->${class_type.name + "::" +  field.name} = json["${class_type.name + "::" +  field.name}"];
        }
    }
    % elif field.type.cx_type.kind == CX.TypeKind.POINTER:
    {
        if (json.find("${class_type.name + "::" +  field.name}") != json.end())
        {
            Engine::Serialization::Archive temp_archive(archive, &json["${class_type.name + "::" +  field.name}"]);
            deserialize(this->${class_type.name + "::" +  field.name}, temp_archive);
        }
        else
        {
            this->${class_type.name + "::" +  field.name} = nullptr;
        }
    }
    % else:
    {
        if (json.find("${class_type.name + "::" +  field.name}") != json.end())
        {
            Engine::Serialization::Archive temp_archive(archive, &json["${class_type.name + "::" +  field.name}"]);
            deserialize(this->${class_type.name + "::" +  field.name}, temp_archive);
        }
    }
    % endif
    % endfor
</%def>
% for class_type in parser.file_type_map[file_path]:
void ${class_type.full_name}::_SERIALIZATION_SAVE_(Engine::Serialization::Archive& archive) const
{
    % for base_type in class_type.base_types:
    % if parser.in_record_type(base_type.full_name):
    ${base_type.name}::_SERIALIZATION_SAVE_(archive);
    % endif
    % endfor
    Engine::Serialization::Json &json = *archive.m_cursor;
    ${generate_type_save(class_type)}
    json["%type"] = "${class_type.full_name}";
}
void ${class_type.full_name}::_SERIALIZATION_LOAD_(Engine::Serialization::Archive& archive)
{
    % for base_type in class_type.base_types:
    % if parser.in_record_type(base_type.full_name):
    ${base_type.name}::_SERIALIZATION_LOAD_(archive);
    % endif
    % endfor
    Engine::Serialization::Json &json = *archive.m_cursor;
    ${generate_type_load(class_type)}
}
${class_type.full_name}::${class_type.name}(Engine::Serialization::SerializationMarker marker) \
<%
base_type_name_list = []
for base_type in class_type.base_types:
    if parser.in_record_type(base_type.full_name):
        base_type_name_list.append(base_type.name)
%>
% if len(base_type_name_list) > 0:
: \
% endif
% for i, base_type_name in enumerate(base_type_name_list):
${base_type_name}(marker)\
% if i < len(base_type_name_list) - 1:
, 
% else:

% endif
% endfor
{
}
% endfor

#pragma GCC diagnostic pop
