#include <Reflection/serialization.h>

<%
import clang.cindex as CX
%>

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-parameter"

## list of all basic types such as bool, int, long double
<% basic_type_list = [CX.TypeKind.from_id(i) for i in range(3, 24)] %>

<%def name="generate_type_save(class_type, prefix)">
    % for base_type in class_type.base_types:
    % if base_type.full_name in classes_map:
    {
        ${generate_type_save(classes_map[base_type.full_name], base_type.name + "::")}  
    }
    % endif
    % endfor

    % for field in class_type.serialized_fields:
    % if field.type.cx_type.kind in basic_type_list:
    {
        json["${prefix + field.name}"] = this->${field.name};
    }
    % elif field.type.cx_type.kind == CX.TypeKind.POINTER:
    {
        if (this->${field.name} != nullptr)
        {
            Engine::Serialization::AddressID adr_id = reinterpret_cast<Engine::Serialization::AddressID>(this->${field.name});
            if (archive.m_context->id_map.find(adr_id) == archive.m_context->id_map.end())
            {
                archive.m_context->id_map[adr_id] = archive.m_context->current_id++;
                std::string str_id = std::string("&") + std::to_string(archive.m_context->id_map[adr_id]);
                archive.m_context->json["%data"][str_id] = Engine::Serialization::Json::object();
                Engine::Serialization::Archive temp_archive(archive, &archive.m_context->json["%data"][str_id]);
                serialize(*this->${field.name}, temp_archive);
            }
            json["${prefix + field.name}"] = std::string("&") + std::to_string(archive.m_context->id_map[adr_id]);;
        }
        else
        {
            json["${prefix + field.name}"] = nullptr;
        }
    }
    % elif field.type.cx_type.kind == CX.TypeKind.CONSTANTARRAY:
    {
        json["${prefix + field.name}"] = Engine::Serialization::Json::array();
        for (const auto& item : this->${field.name})
        {
        % if field.type.cx_type.element_type.kind in basic_type_list:
            json["${prefix + field.name}"].push_back(item);
        % else:
            json["${prefix + field.name}"].push_back(Engine::Serialization::Json::object());
            Engine::Serialization::Archive temp_archive(archive, &json["${prefix + field.name}"].back());
            serialize(item, temp_archive);
        % endif
        }
    }
    % else:
    {
        json["${prefix + field.name}"] = Engine::Serialization::Json::object();
        Engine::Serialization::Archive temp_archive(archive, &json["${prefix + field.name}"]);
        serialize(this->${field.name}, temp_archive);
    }
    % endif
    % endfor
</%def>
% for class_type in classes_map.values():
void ${class_type.full_name}::__serialization_save__(Engine::Serialization::Archive& archive) const
{
    if (!archive.m_context->save_prepared)
        archive.prepare_save("Anything", this);
    Engine::Serialization::Json &json = *archive.m_cursor;
    
    ${generate_type_save(class_type, "")}

    assert(json.find("%type") == json.end());
    json["%type"] = "${class_type.full_name}";
}
<%def name="generate_type_load(class_type, prefix)">
    % for base_type in class_type.base_types:
    % if base_type.full_name in classes_map:
    {
        ${generate_type_load(classes_map[base_type.full_name], base_type.name + "::")}
    }
    % endif
    % endfor
    
    % for field in class_type.serialized_fields:
    % if field.type.cx_type.kind in basic_type_list:
    {
        this->${prefix + field.name} = json["${prefix + field.name}"];
    }
    % elif field.type.cx_type.kind == CX.TypeKind.POINTER:
    {
        if (json.find("${field.name}") != json.end() && !json["${prefix + field.name}"].is_null())
        {
            std::string str_id = json["${prefix + field.name}"].get<std::string>();
            int id = std::stoi(str_id.substr(1));
            if (archive.m_context->pointer_map.find(id) == archive.m_context->pointer_map.end())
            {
                Engine::Serialization::Archive temp_archive(archive, &archive.m_context->json["%data"][str_id]);
                auto type = Engine::Reflection::GetType(archive.m_context->json["%data"][str_id]["%type"].get<std::string>());
                if(type->m_reflectable)
                {
                    Engine::Reflection::Var var = type->CreateInstance();
                    this->${prefix + field.name} = static_cast<decltype(this->${prefix + field.name})>(var.GetDataPtr());
                    archive.m_context->pointer_map[id] = this->${prefix + field.name};
                    deserialize(*this->${prefix + field.name}, temp_archive);
                }
                else
                {
                    assert(type->m_type_info == nullptr || type->m_type_info->name() == typeid(*this->${prefix + field.name}).name());
                    this->${prefix + field.name} = new (std::remove_pointer_t<decltype(this->${prefix + field.name})>)();
                    archive.m_context->pointer_map[id] = this->${prefix + field.name};
                    deserialize(*this->${prefix + field.name}, temp_archive);
                }
            }
            else
            {
                this->${prefix + field.name} = static_cast<decltype(this->${prefix + field.name})>(archive.m_context->pointer_map[id]);
            }
        }
        else
        {
            this->${prefix + field.name} = nullptr;
        }
    }
    % elif field.type.cx_type.kind == CX.TypeKind.CONSTANTARRAY:
    {
        auto &array = json["${prefix + field.name}"];
        for (size_t i = 0; i < array.size(); ++i)
        {
        % if field.type.cx_type.element_type.kind in basic_type_list:
            this->${prefix + field.name}[i] = array[i].get<${field.type.cx_type.element_type.spelling}>();
        % else:
            Engine::Serialization::Archive temp_archive(archive, &array[i]);
            deserialize(this->${prefix + field.name}[i], temp_archive);
        % endif
        }
    }
    % else:
    {
        Engine::Serialization::Archive temp_archive(archive, &json["${prefix + field.name}"]);
        deserialize(this->${prefix + field.name}, temp_archive);
    }
    % endif
    % endfor
</%def>
void ${class_type.full_name}::__serialization_load__(Engine::Serialization::Archive& archive)
{
    if (!archive.m_context->load_prepared)
        archive.prepare_load(this);

    Engine::Serialization::Json &json = *archive.m_cursor;
    ${generate_type_load(class_type, "")}
}
% endfor

#pragma GCC diagnostic pop
