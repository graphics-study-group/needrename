#include <Reflection/serialization.h>

<%
import clang.cindex as CX
%>

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-parameter"

## list of all basic types such as bool, int, long double
<% basic_type_list = [CX.TypeKind.from_id(i) for i in range(3, 24)] %>

<%def name="generate_type_save(class_type, prefix)">
    % for base_type in class_type.base_types:
    % if base_type.full_name in classes_map:
    {
        
        ${generate_type_save(classes_map[base_type.full_name], base_type.name + "::")}
        
    }
    % endif
    % endfor

    % for field in class_type.serialized_fields:
    % if field.type.cx_type.kind in basic_type_list:
    {
        json["${prefix + field.name}"] = this->${field.name};
    }
    % elif field.type.cx_type.kind == CX.TypeKind.POINTER:
    {
        if (this->${field.name} != nullptr)
        {
        % if field.type.cx_type.get_pointee().kind in basic_type_list:
            json["${prefix + field.name}"] = *this->${field.name};
        % else:
            Engine::Serialization::Archive temp_buffer;
            serialize(*this->${field.name}, temp_buffer);
            json["${prefix + field.name}"] = temp_buffer.json;
        % endif
        }
    }
    % elif field.type.cx_type.kind == CX.TypeKind.CONSTANTARRAY:
    {
        json["${prefix + field.name}"] = nlohmann::json::array();
        for (const auto& item : this->${field.name})
        {
        % if field.type.cx_type.element_type.kind in basic_type_list:
            json["${prefix + field.name}"].push_back(item);
        % else:
            Engine::Serialization::Archive temp_buffer;
            serialize(item, temp_buffer);
            json["${prefix + field.name}"].push_back(temp_buffer.json);
            buffer.buffers.insert(buffer.buffers.end(), temp_buffer.buffers.begin(), temp_buffer.buffers.end());
        % endif
        }
    }
    % else:
    {
        Engine::Serialization::Archive temp_buffer;
        serialize(this->${field.name}, temp_buffer);
        json["${prefix + field.name}"] = temp_buffer.json;
        buffer.buffers.insert(buffer.buffers.end(), temp_buffer.buffers.begin(), temp_buffer.buffers.end());
    }
    % endif
    % endfor
</%def>
% for class_type in classes_map.values():
void ${class_type.full_name}::__serialization_save__(Engine::Serialization::Archive& buffer) const
{
    nlohmann::json &json = buffer.json;
    
    ${generate_type_save(class_type, "")}

    assert(json.find("__type") == json.end());
    json["__type"] = "${class_type.full_name}";
}
<%def name="generate_type_load(class_type, prefix)">
    % for base_type in class_type.base_types:
    % if base_type.full_name in classes_map:
    {
        ${generate_type_load(classes_map[base_type.full_name], base_type.name + "::")}
    }
    % endif
    % endfor
    
    % for field in class_type.serialized_fields:
    % if field.type.cx_type.kind in basic_type_list:
    {
        this->${prefix + field.name} = json["${prefix + field.name}"];
    }
    % elif field.type.cx_type.kind == CX.TypeKind.POINTER:
    {
        if (json.find("${field.name}") != json.end())
        {
        % if field.type.cx_type.get_pointee().kind in basic_type_list:
            this->${prefix + field.name} = new ${field.type.cx_type.get_pointee().spelling}(json["${prefix + field.name}"].get<${field.type.cx_type.get_pointee().spelling}>());
        % else:
            Engine::Serialization::Archive temp_buffer = {json["${prefix + field.name}"], buffer.buffers};
            deserialize(*this->${prefix + field.name}, temp_buffer);
        % endif
        }
    }
    % elif field.type.cx_type.kind == CX.TypeKind.CONSTANTARRAY:
    {
        const auto &array = json["${prefix + field.name}"];
        for (size_t i = 0; i < array.size(); ++i)
        {
        % if field.type.cx_type.element_type.kind in basic_type_list:
            this->${prefix + field.name}[i] = array[i].get<${field.type.cx_type.element_type.spelling}>();
        % else:
            Engine::Serialization::Archive temp_buffer = {array[i], buffer.buffers};
            deserialize(this->${prefix + field.name}[i], temp_buffer);
        % endif
        }
    }
    % else:
    {
        Engine::Serialization::Archive temp_buffer = {json["${prefix + field.name}"], buffer.buffers};
        deserialize(this->${prefix + field.name}, temp_buffer);
    }
    % endif
    % endfor
</%def>
void ${class_type.full_name}::__serialization_load__(Engine::Serialization::Archive& buffer)
{
    nlohmann::json &json = buffer.json;

    ${generate_type_load(class_type, "")}
}
% endfor

#pragma GCC diagnostic pop
