#version 450 core
/** Single-pass Navier-Stokes solver, from Simple and Fast Fluids **/
/** Modified from https://www.shadertoy.com/view/XlsBDf **/

#define PI 3.141592653589793

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform UBO {
    int frame_count;
} ubo;

layout(set = 0, binding = 1, rgba32f) uniform restrict readonly image2D inputImage;
layout(set = 0, binding = 2, rgba32f) uniform restrict writeonly image2D outputImage;
layout(set = 0, binding = 3, rgba8) uniform restrict writeonly image2D outputColorImage;

// We have to do a manual bilinear filter as GLSL does not allow sampling for imageXD data
// It is very inefficient, but I'm to lazy to do a different binding on the C++ side.
vec4 sample_input_image(vec2 pixel) {
    ivec2 pixel_int = ivec2(floor(pixel));
    vec2 pixel_frac = fract(pixel);

    vec4 x_1 = imageLoad(inputImage, pixel_int);
    vec4 x_2 = imageLoad(inputImage, pixel_int + ivec2(1, 0));
    vec4 x_3 = imageLoad(inputImage, pixel_int + ivec2(0, 1));
    vec4 x_4 = imageLoad(inputImage, pixel_int + ivec2(1, 1));

    vec4 top = mix(x_1, x_2, pixel_frac.x);
    vec4 bottom = mix(x_3, x_4, pixel_frac.x);

    return mix(top, bottom, pixel_frac.y);
}

vec3 random3(vec3 c) {
    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
    vec3 r;
    r.z = fract(512.0*j);
    j *= .125;
    r.x = fract(512.0*j);
    j *= .125;
    r.y = fract(512.0*j);
    return r-0.5;
}

/* skew constants for 3d simplex functions */
const float F3 =  0.3333333;
const float G3 =  0.1666667;

/* 3d simplex noise */
float simplex3d(vec3 p) {
    vec3 s = floor(p + dot(p, vec3(F3)));
    vec3 x = p - s + dot(s, vec3(G3));
    vec3 e = step(vec3(0.0), x - x.yzx);
    vec3 i1 = e*(1.0 - e.zxy);
    vec3 i2 = 1.0 - e.zxy*(1.0 - e);
    vec3 x1 = x - i1 + G3;
    vec3 x2 = x - i2 + 2.0*G3;
    vec3 x3 = x - 1.0 + 3.0*G3;

    vec4 w, d;

    w.x = dot(x, x);
    w.y = dot(x1, x1);
    w.z = dot(x2, x2);
    w.w = dot(x3, x3);

    w = max(0.6 - w, 0.0);

    d.x = dot(random3(s), x);
    d.y = dot(random3(s + i1), x1);
    d.z = dot(random3(s + i2), x2);
    d.w = dot(random3(s + 1.0), x3);

    w *= w;
    w *= w;
    d *= w;

    return dot(d, vec4(52.0));
}

/*****************************************************************************/


vec2 pen(float t, ivec2 image_size) {
    t *= 0.05;
    return 0.5 * image_size *
        vec2(simplex3d(vec3(t,0,0)) + 1.,
             simplex3d(vec3(0,t,0)) + 1.);
}


#define Load(p) imageLoad(inputImage, p)
#define length2(p) dot(p,p)

#define dt 0.15
#define K 0.2
#define nu 0.5
#define kappa 0.1

void main() {
    vec4 c;
    const ivec2 p = ivec2(gl_GlobalInvocationID.xy);
    const ivec2 texsize = imageSize(inputImage);
    if(ubo.frame_count < 10) {
        c = vec4(0,0,1,0);
    } else {
        c = Load(p);
    
        vec4 n = Load(p + ivec2(0,1));
        vec4 e = Load(p + ivec2(1,0));
        vec4 s = Load(p - ivec2(0,1));
        vec4 w = Load(p - ivec2(1,0));
        
        vec4 laplacian = (n + e + s + w - 4.*c);
        
        vec4 dx = (e - w)/2.;
        vec4 dy = (n - s)/2.;
        
        // velocity field divergence
        float div = dx.x + dy.y;
        
        // mass conservation, Euler method step
        c.z -= dt*(dx.z * c.x + dy.z * c.y + div * c.z);
        
        // semi-Langrangian advection
        c.xyw = sample_input_image(p - dt*c.xy).xyw;
        
        // viscosity/diffusion
        c.xyw += dt * vec3(nu,nu,kappa) * laplacian.xyw;
        
        // nullify divergence with pressure field gradient
        c.xy -= K * vec2(dx.z,dy.z);
        
        // external source
        const float time = ubo.frame_count * 0.15;
        vec2 m = pen(time, texsize);
        c.xyw += dt * exp(-length2(p - m)/50.) * vec3(m - pen(time-0.1, texsize), 1);
        
        // dissipation
        c.w -= dt*0.0005;
        
        c.xyzw = clamp(c.xyzw, vec4(-5,-5,0.5,0), vec4(5,5,3,5));
    }
    imageStore(outputImage, p, c);

    vec4 o;
    o.rgb = .6 + .6 * cos(6.3 * atan(c.y,c.x)/(2.0 * PI) + vec3(0,23,21)); // velocity
    o.rgb *= c.w/5.; // ink
    o.rgb += clamp(c.z - 1., 0., 1.)/10.; // local fluid density
    o.a = 1.;
    imageStore(outputColorImage, p, o);
}
